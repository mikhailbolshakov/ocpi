// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	domain "github.com/mikhailbolshakov/ocpi/domain"
)

// LocationStorage is an autogenerated mock type for the LocationStorage type
type LocationStorage struct {
	mock.Mock
}

// DeleteLocationsByExtId provides a mock function with given fields: ctx, extId
func (_m *LocationStorage) DeleteLocationsByExtId(ctx context.Context, extId domain.PartyExtId) error {
	ret := _m.Called(ctx, extId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, domain.PartyExtId) error); ok {
		r0 = rf(ctx, extId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetConnector provides a mock function with given fields: ctx, locId, evseId, conId
func (_m *LocationStorage) GetConnector(ctx context.Context, locId string, evseId string, conId string) (*domain.Connector, error) {
	ret := _m.Called(ctx, locId, evseId, conId)

	var r0 *domain.Connector
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*domain.Connector, error)); ok {
		return rf(ctx, locId, evseId, conId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *domain.Connector); ok {
		r0 = rf(ctx, locId, evseId, conId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Connector)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, locId, evseId, conId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvse provides a mock function with given fields: ctx, locId, evseId, withConnectors
func (_m *LocationStorage) GetEvse(ctx context.Context, locId string, evseId string, withConnectors bool) (*domain.Evse, error) {
	ret := _m.Called(ctx, locId, evseId, withConnectors)

	var r0 *domain.Evse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (*domain.Evse, error)); ok {
		return rf(ctx, locId, evseId, withConnectors)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) *domain.Evse); ok {
		r0 = rf(ctx, locId, evseId, withConnectors)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Evse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, locId, evseId, withConnectors)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLocation provides a mock function with given fields: ctx, id, withEvse
func (_m *LocationStorage) GetLocation(ctx context.Context, id string, withEvse bool) (*domain.Location, error) {
	ret := _m.Called(ctx, id, withEvse)

	var r0 *domain.Location
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (*domain.Location, error)); ok {
		return rf(ctx, id, withEvse)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) *domain.Location); ok {
		r0 = rf(ctx, id, withEvse)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Location)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, id, withEvse)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeConnector provides a mock function with given fields: ctx, con
func (_m *LocationStorage) MergeConnector(ctx context.Context, con *domain.Connector) error {
	ret := _m.Called(ctx, con)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Connector) error); ok {
		r0 = rf(ctx, con)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MergeEvse provides a mock function with given fields: ctx, evse
func (_m *LocationStorage) MergeEvse(ctx context.Context, evse *domain.Evse) error {
	ret := _m.Called(ctx, evse)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Evse) error); ok {
		r0 = rf(ctx, evse)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MergeLocation provides a mock function with given fields: ctx, loc
func (_m *LocationStorage) MergeLocation(ctx context.Context, loc *domain.Location) error {
	ret := _m.Called(ctx, loc)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Location) error); ok {
		r0 = rf(ctx, loc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SearchConnectors provides a mock function with given fields: ctx, cr
func (_m *LocationStorage) SearchConnectors(ctx context.Context, cr *domain.ConnectorSearchCriteria) (*domain.ConnectorSearchResponse, error) {
	ret := _m.Called(ctx, cr)

	var r0 *domain.ConnectorSearchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.ConnectorSearchCriteria) (*domain.ConnectorSearchResponse, error)); ok {
		return rf(ctx, cr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.ConnectorSearchCriteria) *domain.ConnectorSearchResponse); ok {
		r0 = rf(ctx, cr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ConnectorSearchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *domain.ConnectorSearchCriteria) error); ok {
		r1 = rf(ctx, cr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchEvses provides a mock function with given fields: ctx, cr
func (_m *LocationStorage) SearchEvses(ctx context.Context, cr *domain.EvseSearchCriteria) (*domain.EvseSearchResponse, error) {
	ret := _m.Called(ctx, cr)

	var r0 *domain.EvseSearchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.EvseSearchCriteria) (*domain.EvseSearchResponse, error)); ok {
		return rf(ctx, cr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.EvseSearchCriteria) *domain.EvseSearchResponse); ok {
		r0 = rf(ctx, cr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.EvseSearchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *domain.EvseSearchCriteria) error); ok {
		r1 = rf(ctx, cr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchLocations provides a mock function with given fields: ctx, cr
func (_m *LocationStorage) SearchLocations(ctx context.Context, cr *domain.LocationSearchCriteria) (*domain.LocationSearchResponse, error) {
	ret := _m.Called(ctx, cr)

	var r0 *domain.LocationSearchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.LocationSearchCriteria) (*domain.LocationSearchResponse, error)); ok {
		return rf(ctx, cr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *domain.LocationSearchCriteria) *domain.LocationSearchResponse); ok {
		r0 = rf(ctx, cr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.LocationSearchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *domain.LocationSearchCriteria) error); ok {
		r1 = rf(ctx, cr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConnector provides a mock function with given fields: ctx, con
func (_m *LocationStorage) UpdateConnector(ctx context.Context, con *domain.Connector) error {
	ret := _m.Called(ctx, con)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Connector) error); ok {
		r0 = rf(ctx, con)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateEvse provides a mock function with given fields: ctx, evse
func (_m *LocationStorage) UpdateEvse(ctx context.Context, evse *domain.Evse) error {
	ret := _m.Called(ctx, evse)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Evse) error); ok {
		r0 = rf(ctx, evse)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateLocation provides a mock function with given fields: ctx, loc
func (_m *LocationStorage) UpdateLocation(ctx context.Context, loc *domain.Location) error {
	ret := _m.Called(ctx, loc)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Location) error); ok {
		r0 = rf(ctx, loc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewLocationStorage creates a new instance of LocationStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLocationStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *LocationStorage {
	mock := &LocationStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
