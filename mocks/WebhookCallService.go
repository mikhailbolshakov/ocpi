// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	context "context"

	backend "github.com/mikhailbolshakov/ocpi/backend"

	mock "github.com/stretchr/testify/mock"
)

// WebhookCallService is an autogenerated mock type for the WebhookCallService type
type WebhookCallService struct {
	mock.Mock
}

// OnCancelReservation provides a mock function with given fields: ctx, cmd
func (_m *WebhookCallService) OnCancelReservation(ctx context.Context, cmd *backend.Command) error {
	ret := _m.Called(ctx, cmd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *backend.Command) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnCdrChanged provides a mock function with given fields: ctx, cdr
func (_m *WebhookCallService) OnCdrChanged(ctx context.Context, cdr *backend.Cdr) error {
	ret := _m.Called(ctx, cdr)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *backend.Cdr) error); ok {
		r0 = rf(ctx, cdr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnCommandResponse provides a mock function with given fields: ctx, cmd
func (_m *WebhookCallService) OnCommandResponse(ctx context.Context, cmd *backend.Command) error {
	ret := _m.Called(ctx, cmd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *backend.Command) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnConnectorChanged provides a mock function with given fields: ctx, cons
func (_m *WebhookCallService) OnConnectorChanged(ctx context.Context, cons ...*backend.Connector) error {
	_va := make([]interface{}, len(cons))
	for _i := range cons {
		_va[_i] = cons[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Connector) error); ok {
		r0 = rf(ctx, cons...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnEvseChanged provides a mock function with given fields: ctx, evses
func (_m *WebhookCallService) OnEvseChanged(ctx context.Context, evses ...*backend.Evse) error {
	_va := make([]interface{}, len(evses))
	for _i := range evses {
		_va[_i] = evses[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Evse) error); ok {
		r0 = rf(ctx, evses...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnLocationsChanged provides a mock function with given fields: ctx, locs
func (_m *WebhookCallService) OnLocationsChanged(ctx context.Context, locs ...*backend.Location) error {
	_va := make([]interface{}, len(locs))
	for _i := range locs {
		_va[_i] = locs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Location) error); ok {
		r0 = rf(ctx, locs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnPartiesChanged provides a mock function with given fields: ctx, parties
func (_m *WebhookCallService) OnPartiesChanged(ctx context.Context, parties ...*backend.Party) error {
	_va := make([]interface{}, len(parties))
	for _i := range parties {
		_va[_i] = parties[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Party) error); ok {
		r0 = rf(ctx, parties...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnReserveNow provides a mock function with given fields: ctx, cmd
func (_m *WebhookCallService) OnReserveNow(ctx context.Context, cmd *backend.Command) error {
	ret := _m.Called(ctx, cmd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *backend.Command) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnSessionsChanged provides a mock function with given fields: ctx, sessions
func (_m *WebhookCallService) OnSessionsChanged(ctx context.Context, sessions ...*backend.Session) error {
	_va := make([]interface{}, len(sessions))
	for _i := range sessions {
		_va[_i] = sessions[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Session) error); ok {
		r0 = rf(ctx, sessions...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnStartSession provides a mock function with given fields: ctx, cmd
func (_m *WebhookCallService) OnStartSession(ctx context.Context, cmd *backend.Command) error {
	ret := _m.Called(ctx, cmd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *backend.Command) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnStopSession provides a mock function with given fields: ctx, cmd
func (_m *WebhookCallService) OnStopSession(ctx context.Context, cmd *backend.Command) error {
	ret := _m.Called(ctx, cmd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *backend.Command) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnTariffsChanged provides a mock function with given fields: ctx, tariffs
func (_m *WebhookCallService) OnTariffsChanged(ctx context.Context, tariffs ...*backend.Tariff) error {
	_va := make([]interface{}, len(tariffs))
	for _i := range tariffs {
		_va[_i] = tariffs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Tariff) error); ok {
		r0 = rf(ctx, tariffs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OnTokensChanged provides a mock function with given fields: ctx, tokens
func (_m *WebhookCallService) OnTokensChanged(ctx context.Context, tokens ...*backend.Token) error {
	_va := make([]interface{}, len(tokens))
	for _i := range tokens {
		_va[_i] = tokens[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*backend.Token) error); ok {
		r0 = rf(ctx, tokens...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewWebhookCallService creates a new instance of WebhookCallService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWebhookCallService(t interface {
	mock.TestingT
	Cleanup(func())
}) *WebhookCallService {
	mock := &WebhookCallService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
